// -------------------------------------------------------------
// 
// File Name: hdlsrc_V5\untitled\serial_lpf.v
// Created: 2022-06-11 22:31:21
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 0.25
// Target subsystem base rate: 0.25
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// y_out                         ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: serial_lpf
// Source Path: untitled/serial_lpf
// Hierarchy Level: 0
// 
// Simulink model description for untitled:
// 
// Symmetric FIR Filter
// This example shows how to use HDL Coder(TM) to check, generate,
// and verify HDL for a fixed-point symmetric FIR filter. 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module serial_lpf
          (clk,
           reset,
           clk_enable,
           x_in,
           h_in5,
           h_in6,
           h_in7,
           h_in8,
           ce_out,
           y_out);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [15:0] x_in;  // sfix16_En10
  input   signed [15:0] h_in5;  // sfix16_En10
  input   signed [15:0] h_in6;  // sfix16_En10
  input   signed [15:0] h_in7;  // sfix16_En10
  input   signed [15:0] h_in8;  // sfix16_En10
  output  ce_out;
  output  signed [34:0] y_out;  // sfix35_En20


  wire enb;
  wire enb_1_4_1;
  wire enb_1_4_0;
  reg [1:0] HDL_Counter2_out1;  // ufix2
  wire [1:0] count;  // ufix2
  wire need_to_wrap;
  wire [1:0] count_value;  // ufix2
  wire [7:0] FromFix_out1;  // uint8
  wire Compare_To_Constant_out1;
  reg signed [15:0] ud1_out1;  // sfix16_En10
  reg signed [15:0] ud2_out1;  // sfix16_En10
  reg signed [15:0] ud3_out1;  // sfix16_En10
  reg signed [15:0] ud4_out1;  // sfix16_En10
  wire signed [15:0] Repeat3_out1 [0:3];  // sfix16_En10 [4]
  wire signed [15:0] Selector2_out1;  // sfix16_En10
  reg signed [15:0] ud5_out1;  // sfix16_En10
  reg signed [15:0] ud6_out1;  // sfix16_En10
  reg signed [15:0] ud7_out1;  // sfix16_En10
  reg signed [15:0] ud8_out1;  // sfix16_En10
  wire signed [15:0] Repeat1_out1 [0:3];  // sfix16_En10 [4]
  wire signed [15:0] Selector_out1;  // sfix16_En10
  wire signed [15:0] Repeat2_out1 [0:3];  // sfix16_En10 [4]
  wire signed [15:0] Selector1_out1;  // sfix16_En10
  wire signed [34:0] Subsystem4_out1;  // sfix35_En20
  reg signed [34:0] Accumulator_out1;  // sfix35_En20
  wire signed [34:0] Switch_out1;  // sfix35_En20
  reg signed [34:0] Unit_Delay_Enabled_out1;  // sfix35_En20
  reg signed [34:0] rtslow_bypass_reg;  // sfix35
  wire signed [34:0] rtslow_out1;  // sfix35_En20


  serial_lpf_tc u_serial_lpf_tc (.clk(clk),
                                 .reset(reset),
                                 .clk_enable(clk_enable),
                                 .enb(enb),
                                 .enb_1_4_0(enb_1_4_0),
                                 .enb_1_4_1(enb_1_4_1)
                                 );

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 3
  assign count = HDL_Counter2_out1 + 2'b01;


  assign need_to_wrap = HDL_Counter2_out1 == 2'b11;


  assign count_value = (need_to_wrap == 1'b0 ? count :
              2'b00);


  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 2'b00;
      end
      else begin
        if (enb) begin
          HDL_Counter2_out1 <= count_value;
        end
      end
    end


  assign FromFix_out1 = {6'b0, HDL_Counter2_out1};


  assign Compare_To_Constant_out1 = FromFix_out1 == 8'b00000011;


  always @(posedge clk or posedge reset)
    begin : ud1_process
      if (reset == 1'b1) begin
        ud1_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud1_out1 <= x_in;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud2_process
      if (reset == 1'b1) begin
        ud2_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud2_out1 <= ud1_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud3_process
      if (reset == 1'b1) begin
        ud3_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud3_out1 <= ud2_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud4_process
      if (reset == 1'b1) begin
        ud4_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud4_out1 <= ud3_out1;
        end
      end
    end


  assign Repeat3_out1[0] = ud1_out1;
  assign Repeat3_out1[1] = ud2_out1;
  assign Repeat3_out1[2] = ud3_out1;
  assign Repeat3_out1[3] = ud4_out1;
  assign Selector2_out1 = (FromFix_out1 == 8'b00000000 ? Repeat3_out1[0] :
              (FromFix_out1 == 8'b00000001 ? Repeat3_out1[1] :
              (FromFix_out1 == 8'b00000010 ? Repeat3_out1[2] :
              Repeat3_out1[3])));


  always @(posedge clk or posedge reset)
    begin : ud5_process
      if (reset == 1'b1) begin
        ud5_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud5_out1 <= ud4_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud6_process
      if (reset == 1'b1) begin
        ud6_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud6_out1 <= ud5_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud7_process
      if (reset == 1'b1) begin
        ud7_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud7_out1 <= ud6_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : ud8_process
      if (reset == 1'b1) begin
        ud8_out1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_4_0) begin
          ud8_out1 <= ud7_out1;
        end
      end
    end


  assign Repeat1_out1[0] = ud8_out1;
  assign Repeat1_out1[1] = ud7_out1;
  assign Repeat1_out1[2] = ud6_out1;
  assign Repeat1_out1[3] = ud5_out1;
  assign Selector_out1 = (FromFix_out1 == 8'b00000000 ? Repeat1_out1[0] :
              (FromFix_out1 == 8'b00000001 ? Repeat1_out1[1] :
              (FromFix_out1 == 8'b00000010 ? Repeat1_out1[2] :
              Repeat1_out1[3])));


  assign Repeat2_out1[0] = h_in5;
  assign Repeat2_out1[1] = h_in6;
  assign Repeat2_out1[2] = h_in7;
  assign Repeat2_out1[3] = h_in8;
  assign Selector1_out1 = (FromFix_out1 == 8'b00000000 ? Repeat2_out1[0] :
              (FromFix_out1 == 8'b00000001 ? Repeat2_out1[1] :
              (FromFix_out1 == 8'b00000010 ? Repeat2_out1[2] :
              Repeat2_out1[3])));


  always @(posedge clk or posedge reset)
    begin : Accumulator_process
      if (reset == 1'b1) begin
        Accumulator_out1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          Accumulator_out1 <= Subsystem4_out1;
        end
      end
    end


  assign Switch_out1 = (FromFix_out1 == 8'b00000000 ? 35'sh000000000 :
              Accumulator_out1);


  Subsystem4 u_Subsystem4 (.In1(Selector2_out1),  // sfix16_En10
                           .In2(Selector_out1),  // sfix16_En10
                           .In3(Selector1_out1),  // sfix16_En10
                           .In4(Switch_out1),  // sfix35_En20
                           .Out1(Subsystem4_out1)  // sfix35_En20
                           );
  always @(posedge clk or posedge reset)
    begin : Unit_Delay_Enabled_process
      if (reset == 1'b1) begin
        Unit_Delay_Enabled_out1 <= 35'sh000000000;
      end
      else begin
        if (enb && Compare_To_Constant_out1) begin
          Unit_Delay_Enabled_out1 <= Subsystem4_out1;
        end
      end
    end


  always @(posedge clk or posedge reset)
    begin : rtslow_bypass_process
      if (reset == 1'b1) begin
        rtslow_bypass_reg <= 35'sh000000000;
      end
      else begin
        if (enb_1_4_1) begin
          rtslow_bypass_reg <= Unit_Delay_Enabled_out1;
        end
      end
    end

  assign rtslow_out1 = (enb_1_4_1 == 1'b1 ? Unit_Delay_Enabled_out1 :
              rtslow_bypass_reg);


  assign y_out = rtslow_out1;

  assign ce_out = enb_1_4_1;

endmodule  // serial_lpf

